$date
  Fri Oct 23 22:49:53 2020
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module processor_tb $end
$var reg 1 ! clk $end
$var reg 3 " ci[2:0] $end
$var reg 8 # val[7:0] $end
$scope module uut $end
$var reg 1 $ clk $end
$var reg 3 % current_instruction[2:0] $end
$var reg 8 & value[7:0] $end
$var reg 2 ' synthesized_wire_0[1:0] $end
$var reg 8 ( synthesized_wire_1[7:0] $end
$var reg 8 ) synthesized_wire_2[7:0] $end
$var reg 2 * synthesized_wire_3[1:0] $end
$var reg 3 + synthesized_wire_17[2:0] $end
$var reg 1 , synthesized_wire_5 $end
$var reg 2 - synthesized_wire_18[1:0] $end
$var reg 2 . synthesized_wire_19[1:0] $end
$var reg 1 / synthesized_wire_8 $end
$var reg 8 0 synthesized_wire_9[7:0] $end
$var reg 8 1 synthesized_wire_10[7:0] $end
$var reg 2 2 synthesized_wire_12[1:0] $end
$var reg 2 3 synthesized_wire_13[1:0] $end
$var reg 8 4 synthesized_wire_15[7:0] $end
$scope module b2v_arithmetic_logic_unit $end
$var reg 2 5 op[1:0] $end
$var reg 8 6 rs[7:0] $end
$var reg 8 7 rt[7:0] $end
$var reg 8 8 rd[7:0] $end
$var reg 8 9 result[7:0] $end
$upscope $end
$scope module b2v_control_unit $end
$var reg 2 : instr[1:0] $end
$var reg 2 ; alu_op[1:0] $end
$var reg 1 < alu_src $end
$var reg 1 = reg_dst $end
$upscope $end
$scope module b2v_instruction_memory $end
$var reg 3 > instr_addr[2:0] $end
$var reg 2 ? op[1:0] $end
$var reg 2 @ rs_addr[1:0] $end
$var reg 2 A rt_addr[1:0] $end
$var reg 2 B rd_addr[1:0] $end
$upscope $end
$scope module b2v_mux0 $end
$var reg 1 C sel $end
$var reg 2 D a[1:0] $end
$var reg 2 E b[1:0] $end
$var reg 2 F y[1:0] $end
$upscope $end
$scope module b2v_mux1 $end
$var reg 1 G sel $end
$var reg 8 H a[7:0] $end
$var reg 8 I b[7:0] $end
$var reg 8 J y[7:0] $end
$upscope $end
$scope module b2v_program_counter $end
$var reg 1 K clk $end
$var reg 3 L current_instr[2:0] $end
$var reg 3 M next_instr[2:0] $end
$var reg 3 N next_signal[2:0] $end
$upscope $end
$scope module b2v_registers_file $end
$var reg 1 O clk $end
$var reg 2 P rs_addr[1:0] $end
$var reg 2 Q rt_addr[1:0] $end
$var reg 2 R rd_addr[1:0] $end
$var reg 8 S wr_data[7:0] $end
$var reg 8 T rs[7:0] $end
$var reg 8 U rt[7:0] $end
$comment reg is not handled $end
$upscope $end
$scope module b2v_sign_extend $end
$var reg 2 V data_in[1:0] $end
$var reg 8 W data_out[7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
b000 "
b00000011 #
0$
b000 %
b00000011 &
b11 '
b00000001 (
b00000010 )
b11 *
b000 +
1,
b00 -
b10 .
1/
b00000001 0
b00000010 1
b00 2
b00 3
b00000011 4
b11 5
b00000001 6
b00000010 7
b00000011 8
b00000011 9
b11 :
b11 ;
1<
1=
b000 >
b11 ?
b00 @
b00 A
b10 B
1C
b00 D
b10 E
b00 F
1G
b00000001 H
b00000010 I
b00000010 J
0K
b000 L
b000 M
b000 N
0O
b00 P
b00 Q
b00 R
b00000011 S
b00000001 T
b00000001 U
b10 V
b00000010 W
#10000000
1!
1$
1K
1O
#20000000
0!
b001 "
b00000011 #
0$
b001 %
b00000011 &
b00000010 (
b00000001 )
b001 +
b01 -
b01 .
b00000010 0
b00000001 1
b01 2
b01 3
b00000011 4
b00000010 6
b00000001 7
b00000011 8
b00000011 9
b001 >
b01 @
b01 A
b01 B
b01 D
b01 E
b01 F
b00000010 H
b00000001 I
b00000001 J
0K
b001 L
b001 M
b001 N
0O
b01 P
b01 Q
b01 R
b00000011 S
b00000010 T
b00000010 U
b01 V
b00000001 W
#30000000
1!
1$
1K
1O
#40000000
0!
b010 "
b00000110 #
0$
b010 %
b00000110 &
b00000011 (
b00000011 )
b010 +
b10 -
b11 .
b00000011 0
b00000011 1
b10 2
b10 3
b00000110 4
b00000011 6
b00000011 7
b00000110 8
b00000110 9
b010 >
b10 @
b10 A
b11 B
b10 D
b11 E
b10 F
b00000011 H
b00000011 I
b00000011 J
0K
b010 L
b010 M
b010 N
0O
b10 P
b10 Q
b10 R
b00000110 S
b00000011 T
b00000011 U
b11 V
b00000011 W
#50000000
1!
1$
1K
1O
#60000000
0!
b011 "
b00000110 #
0$
b011 %
b00000110 &
b01 '
b00000011 (
b01 *
b011 +
0,
b01 -
0/
b00000011 0
b11 2
b00 3
b00000110 4
b01 5
b00000011 6
b00000110 8
b00000110 9
b01 :
b01 ;
0<
0=
b011 >
b01 ?
b00 @
b01 A
0C
b01 D
b11 F
0G
b00000011 H
0K
b011 L
b011 M
b011 N
0O
b00 P
b01 Q
b11 R
b00000110 S
b00000011 T
b00000011 U
#70000000
1!
1$
1K
1O
#80000000
0!
b100 "
b00000000 #
0$
b100 %
b00000000 &
b10 '
b00000110 (
b00000110 )
b10 *
b100 +
b11 -
b00 .
b00000110 0
b00000000 1
b00 2
b10 3
b00000000 4
b10 5
b00000110 6
b00000110 7
b00000000 8
b00000000 9
b10 :
b10 ;
b100 >
b10 ?
b10 @
b11 A
b00 B
b11 D
b00 E
b00 F
b00000110 H
b00000000 I
b00000110 J
0K
b100 L
b100 M
b100 N
0O
b10 P
b11 Q
b00 R
b00000000 S
b00000110 T
b00000110 U
b00 V
b00000000 W
#90000000
1!
1$
1K
1O
#100000000
0!
b101 "
0$
b101 %
b00 '
b00000000 (
b00000000 )
b00 *
b101 +
b00 -
b00000000 0
b00 3
b00 5
b00000000 6
b00000000 7
b00 :
b00 ;
b101 >
b00 ?
b00 @
b00 A
b00 D
b00000000 H
b00000000 J
0K
b101 L
b101 M
b101 N
0O
b00 P
b00 Q
b00000000 T
b00000000 U
#110000000
1!
1$
1K
1O
#120000000
0!
b110 "
0$
b110 %
b110 +
b110 >
0K
b110 L
b110 M
b110 N
0O
#130000000
1!
1$
1K
1O
#140000000
0!
b111 "
0$
b111 %
b111 +
b111 >
0K
b111 L
b111 M
b111 N
0O
#150000000
1!
1$
1K
1O
#160000000
0!
b000 "
b00000010 #
0$
b000 %
b00000010 &
b11 '
b00000010 )
b11 *
b000 +
1,
b10 .
1/
b00000010 1
b00 2
b00000010 4
b11 5
b00000010 7
b00000010 8
b00000010 9
b11 :
b11 ;
1<
1=
b000 >
b11 ?
b10 B
1C
b10 E
b00 F
1G
b00000010 I
b00000010 J
0K
b000 L
b000 M
b000 N
0O
b00 R
b00000010 S
b10 V
b00000010 W
#170000000
1!
1$
1K
1O
#180000000
0!
b001 "
b00000100 #
0$
b001 %
b00000100 &
b00000011 (
b00000001 )
b001 +
b01 -
b01 .
b00000011 0
b00000001 1
b01 2
b01 3
b00000100 4
b00000011 6
b00000001 7
b00000100 8
b00000100 9
b001 >
b01 @
b01 A
b01 B
b01 D
b01 E
b01 F
b00000011 H
b00000001 I
b00000001 J
0K
b001 L
b001 M
b001 N
0O
b01 P
b01 Q
b01 R
b00000100 S
b00000011 T
b00000011 U
b01 V
b00000001 W
#190000000
1!
1$
1K
1O
#200000000
0!
b010 "
b00001001 #
0$
b010 %
b00001001 &
b00000110 (
b00000011 )
b010 +
b10 -
b11 .
b00000110 0
b00000011 1
b10 2
b10 3
b00001001 4
b00000110 6
b00000011 7
b00001001 8
b00001001 9
b010 >
b10 @
b10 A
b11 B
b10 D
b11 E
b10 F
b00000110 H
b00000011 I
b00000011 J
0K
b010 L
b010 M
b010 N
0O
b10 P
b10 Q
b10 R
b00001001 S
b00000110 T
b00000110 U
b11 V
b00000011 W
